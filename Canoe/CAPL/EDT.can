/*@!Encoding:65001*/
includes
{
  
}

variables
{
  msTimer otaTimer;
  message EDT_CGW_E_OTA_RESULT otaResMsg;
  message EDT_TMU_E_VER_INFO edtVerMsg;
  enum STATE
  {
    NOMAR_MODE,
    BOOTLOADER_MODE,
    OTA_COMPLETE
  }edtState = BOOTLOADER_MODE;
 
  dword hFile;
  char update_ver[1];
  char cur_ver[2];
  char ota_data[2];
  //byte bytebuffer[256];
  long len = 256;
  long result;
  int i = 0;
  int mode = 0; // 0 : 첫 부팅시 부트로더 모드, 1 : ota로 인한 부트로더 모드, 2 : 기본
  int ota_result = 0;
  int cur_edt_version = 0;
  int edt_num = 3;
  int version_num[11] = {0, 1, 2, 3, 4, 5,
                         6, 7, 8, 9, 10};
                         

}
on start
{
  setTimer(otaTimer, 100);
}

int writeBootloader()
{
  hFile = openFileWrite("EDT_version.txt", 0);
  if (hFile != 0)
  {
    snprintf(update_ver, 8, "%d", cur_edt_version);
    filePutString(update_ver, 1, hFile);
    fileClose(hFile);
    return 1;
  }
  else
  {
    return 0;
  }
}
void updateVersion()
{
  //@sysvar::Cur_Ver[3] = @sysvar::Next_Ver[3];
 // cur_edt_version = @sysvar::Next_Ver[3];
  cur_edt_version = (ota_data[1] & 0x0F);
}
void readBootloader() // 현재 버전 읽어오기
{
  hFile = openFileRead("EDT_version.txt", 0);
  fileGetString(cur_ver, 2, hFile);
  //@sysvar::Cur_Ver[3] = _atoi64(cur_ver);
  //cur_edt_version = @sysvar::Cur_Ver[3];
  cur_edt_version = _atoi64(cur_ver);
  fileClose(hFile);
}
void sendEdtVersion()
{
  edtVerMsg.byte(0) = ((0x00 | edt_num << 4) | cur_edt_version);
  output(edtVerMsg);
}
on timer otaTimer
{
  switch (edtState)
  {
    case NOMAR_MODE: // Default
      if (cur_edt_version >= version_num[1])
      {
        // version : 1
      }
      /*if (cur_edt_version >= version_num[2])
      {
        // version : 2
        if (@sysvar::Distance > 20)
        {
          if (@sysvar::vehSpeed <= 200)
          {
            @sysvar::vehSpeed += @sysvar::addSpeed*0.0002;
          }
        }
        else
        {
          if (@sysvar::vehSpeed > 0)
          {
            @sysvar::vehSpeed--;   
          }
        } 
      }
      */
      break;
    case BOOTLOADER_MODE:
      if (mode == 0)
      {
        write(">>> EDT 첫 부팅 bootMode 진입");
        readBootloader(); // 현재 저장된 버전 가져오기
        sendEdtVersion();
        edtState = NOMAR_MODE;
      }
      else if (mode == 1)
      {
        write(">>> OTA bootMode 진입");
        updateVersion();
        ota_result = writeBootloader();
        edtState = OTA_COMPLETE;
      }
      
      break;
    case OTA_COMPLETE:
      write(">>> 현재 버전: %d", cur_edt_version);
      if (ota_result == 1)
      {
        write(">>> OTA Success!");
        otaResMsg.byte(0) = 0x05; // Send Complete Msg to CGW
        otaResMsg.byte(1) = ((0x00 | (edt_num << 4)) | cur_edt_version);
        output(otaResMsg);
      }
      else
      {
        write(">>> OTA Fail!");
        otaResMsg.byte(0) = 0xFF;
      }
      edtState = NOMAR_MODE;
      break;
  }
  setTimer(otaTimer, 100);
}

on message CGW_EDT_PE_OTA_DATA
{
  if (this.byte(0) == 0x04)
  {
    
    if ((this.byte(1) & 0xF0) == 0x30)
    {
      mode = 1;
      edtState = BOOTLOADER_MODE;
      ota_data[1] = this.byte(1);
      //write("%d", ota_data[1]);
    }
    /*if (@sysvar::Next_Ver[3] != 0)
    {
      mode = 1;
      edtState = BOOTLOADER_MODE;
    }
    */
  }
}


