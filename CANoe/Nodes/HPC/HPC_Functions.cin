/*@!Encoding:65001*/
void OnEnterFailSafe()
{
  message M001_Regen_Torque_Cmd emergencyCmd;
  message M004_FailSafe_Status_1 failSafeMsg;

  write("HPC: FAIL-SAFE mode activated. Regenerative braking disabled.");
  currentRegenMode = REGEN_OFF;
  targetRegenTorque = 0.0;

  emergencyCmd.Target_Regen_Torque = 32000;
  emergencyCmd.Regen_Mode = 0;
  emergencyCmd.Torque_Rate_Limit = 255;
  output(emergencyCmd);

  output(failSafeMsg);
}

void OnEnterBatteryProtection()
{
  write("HPC: BATTERY-PROTECTION mode activated. Regen torque limited.");
  SetFault(FAULT_BATTERY_PROTECTION);
}

void OnEnterNormal()
{
  write("HPC: NORMAL operation resumed.");
  ClearFault(FAULT_BATTERY_PROTECTION);
}

void TransitionToState(enum SystemState newState)
{
  if (newState != currentState)
  {
    previousState = currentState;
    currentState = newState;
    write("HPC: State transition %d -> %d", previousState, currentState);
    switch (newState)
    {
      case STATE_FAIL_SAFE: OnEnterFailSafe(); break;
      case STATE_BATTERY_PROTECTION: OnEnterBatteryProtection(); break;
      case STATE_NORMAL: OnEnterNormal(); break;
      default: break;
    }
  }
}

void SetFault(dword faultBit)
{
  if((faultRegister & faultBit) == 0)
  {
    faultRegister |= faultBit;
    diagnostics.errorFlags = faultRegister;
  }
}

void ClearFault(dword faultBit)
{
  faultRegister &= ~faultBit;
  diagnostics.errorFlags = faultRegister;
}

void InitializeGlobals()
{
  currentState = STATE_INIT;
  previousState = STATE_INIT;
  currentRegenMode = REGEN_OFF;
  
  currentVehicleSpeed = 0.0;
  currentMotorSpeed = 0.0;
  currentRegenTorque = 0.0;
  targetRegenTorque = 0.0;
  maxRegenPower = 0.0;
  cumulativeRegenEnergy = 0.0;
  instantRegenPower = 0.0;
  
  batterySOC = 0;
  batteryTemp = 0;
  steeringAngle = 0.0;
  apsPosition = 0;
  
  faultRegister = 0;
  diagnostics.errorFlags = 0;
  watchdogCounter = 0;
  gTaskCounter = 0;

  gPrevVehicleSpeed_VD = 0;
  gPrevTime_VD = 0;
}

float CalculateRegenTorque(float vehicleSpeed, enum RegenState mode, struct V2XData v2x)
{
  float baseTorque = 0.0;
  switch (mode)
  {
    case REGEN_LEVEL1: baseTorque = 50.0; break;
    case REGEN_LEVEL2: baseTorque = 100.0; break;
    case REGEN_LEVEL3: baseTorque = 150.0; break;
    case REGEN_AUTO:
      baseTorque = 100.0;
      if (v2x.trafficLightStatus == 1) baseTorque *= 1.5;
      if (v2x.roadGrade > 5) baseTorque *= 1.3;
      break;
    default: baseTorque = 0.0; break;
  }

  if (vehicleSpeed < 10.0) baseTorque *= 0.3;
  else if (vehicleSpeed > 80.0) baseTorque *= 1.2;

  if (currentState == STATE_BATTERY_PROTECTION) baseTorque *= 0.5;
  
  return baseTorque;
}

void SendModeChangeResponse(message M008_Mode_Change_Req request)
{
    message M009_Mode_Change_Resp response;
    
    if (currentState == STATE_NORMAL || currentState == STATE_BATTERY_PROTECTION)
    {
        currentRegenMode = (enum RegenState)request.Requested_Mode;
        response.Mode_Change_Status = 0;
        response.Failure_Reason = 0;
    }
    else
    {
        response.Mode_Change_Status = 1;
        response.Failure_Reason = 3;
    }

    response.Current_Mode = (byte)currentRegenMode;
    response.Active_Profile = request.Profile_Type;
    response.Response_Timestamp = (word)timeNow();

    gCrcData[0] = response.Current_Mode;
    gCrcData[1] = response.Mode_Change_Status;
    gCrcData[2] = response.Active_Profile;
    gCrcData[3] = response.Failure_Reason;
    gCrcData[4] = (byte)(response.Response_Timestamp & 0xFF);
    gCrcData[5] = (byte)((response.Response_Timestamp >> 8) & 0xFF);
    
    gCrcRetval = Crc_CalculateCRC16(gCrcData, 6, 0, 6, 0, 1, gCrcValue);
    if (gCrcRetval == 0)
    {
        response.CRC16_Checksum = (word)gCrcValue;
    }
    else
    {
        write("HPC: CRC Calculation failed for M009_Mode_Change_Resp with error: %d", gCrcRetval);
        response.CRC16_Checksum = 0x0000;
    }

    output(response);
}


void ExecuteRegenTorqueTask()
{
  message M001_Regen_Torque_Cmd cmd;

  if(currentState == STATE_FAIL_SAFE) return;

  targetRegenTorque = CalculateRegenTorque(currentVehicleSpeed, currentRegenMode, v2xData);
  
  cmd.Target_Regen_Torque = (word)((targetRegenTorque + 3200) / 0.1);
  cmd.Regen_Mode = (byte)currentRegenMode;
  cmd.Torque_Rate_Limit = 25;
  cmd.E2E_Counter = ++watchdogCounter;
  cmd.Max_Regen_Power = (byte)(maxRegenPower / 0.5);

  gCrcData[0] = (byte)(cmd.Target_Regen_Torque & 0xFF);
  gCrcData[1] = (byte)((cmd.Target_Regen_Torque >> 8) & 0xFF);
  gCrcData[2] = cmd.Regen_Mode;
  gCrcData[3] = cmd.Torque_Rate_Limit;
  gCrcData[4] = cmd.E2E_Counter;
  gCrcData[5] = cmd.Max_Regen_Power;

  gCrcRetval = Crc_CalculateCRC16(gCrcData, 6, 0, 6, 0, 1, gCrcValue);
  if (gCrcRetval == 0)
  {
      cmd.E2E_CRC16 = (word)gCrcValue;
  }
  else
  {
      write("HPC: CRC Calculation failed for M001_Regen_Torque_Cmd with error: %d", gCrcRetval);
      cmd.E2E_CRC16 = 0x0000;
  }
  
  output(cmd);
  
  setTimer(timerWatchdog, WATCHDOG_TIMEOUT);
}

void ExecuteAutoModeOptimizationTask()
{
  if (currentRegenMode == REGEN_AUTO && currentState == STATE_NORMAL)
  {
    float optimizedTorque;
    optimizedTorque = CalculateRegenTorque(currentVehicleSpeed, REGEN_AUTO, v2xData) * 1.1;
    if (optimizedTorque != targetRegenTorque)
    {
      targetRegenTorque = optimizedTorque;
      write("HPC: Auto mode optimized torque: %.2f Nm", optimizedTorque);
    }
  }
}

void ExecuteClusterDisplayTask()
{
  message M012_Cluster_Display display;
  
  display.Display_Mode = (byte)currentRegenMode;
  display.Instant_Regen_Power = (word)(instantRegenPower / 100);
  display.Cumulative_Regen_Energy = (word)(cumulativeRegenEnergy / 10);
  display.Warning_Status = (currentState == STATE_BATTERY_PROTECTION) ? 0x01 : 0x00;
  display.Vehicle_Speed = (word)(currentVehicleSpeed * 100);
  display.Motor_Speed = (word)currentMotorSpeed;

  gCrcData[0] = display.Display_Mode;
  gCrcData[1] = (byte)(display.Instant_Regen_Power & 0xFF);
  gCrcData[2] = (byte)((display.Instant_Regen_Power >> 8) & 0xFF);
  gCrcData[3] = (byte)(display.Cumulative_Regen_Energy & 0xFF);
  gCrcData[4] = (byte)((display.Cumulative_Regen_Energy >> 8) & 0xFF);
  gCrcData[5] = display.Warning_Status;
  gCrcData[6] = (byte)(display.Vehicle_Speed & 0xFF);
  gCrcData[7] = (byte)((display.Vehicle_Speed >> 8) & 0xFF);
  gCrcData[8] = (byte)(display.Motor_Speed & 0xFF);
  gCrcData[9] = (byte)((display.Motor_Speed >> 8) & 0xFF);

  gCrcRetval = Crc_CalculateCRC16(gCrcData, 10, 0, 10, 0, 1, gCrcValue);
  if (gCrcRetval == 0)
  {
      display.CRC16_Checksum = (word)gCrcValue;
  }
  else
  {
      write("HPC: CRC Calculation failed for M012_Cluster_Display with error: %d", gCrcRetval);
      display.CRC16_Checksum = 0x0000;
  }
  
  output(display);
}

void ExecuteEnergyEfficiencyTask()
{
    instantRegenPower = targetRegenTorque * currentVehicleSpeed * 0.1047; // Power (W)
    cumulativeRegenEnergy += instantRegenPower * (MAIN_CYCLE * 4 / 3600000.0);
}

void HandleMainTaskTimer()
{
  ExecuteRegenTorqueTask();

  if ((gTaskCounter % 10) == 0)
  {
    ExecuteClusterDisplayTask();
  }

  if ((gTaskCounter % 20) == 0)
  {
    ExecuteEnergyEfficiencyTask();
  }
  
  if ((gTaskCounter % 50) == 0)
  {
    ExecuteAutoModeOptimizationTask();
  }
  
  gTaskCounter++;
}

void HandleStartEvent()
{
  write("HPC: Regenerative Braking System Starting - Version %d.%02d", (SYSTEM_VERSION >> 8), (SYSTEM_VERSION & 0xFF));
  InitializeGlobals();
  
  setTimerCyclic(timerMainTask, MAIN_CYCLE);
  setTimer(timerWatchdog, WATCHDOG_TIMEOUT);
  
  TransitionToState(STATE_NORMAL);
}

void HandleStopEvent()
{
  write("HPC: Shutting down...");
  write("HPC: Shutdown complete");
}

void HandleWatchdogTimeout()
{
  write("HPC: WATCHDOG TIMEOUT - Entering FailSafe mode");
  SetFault(FAULT_WATCHDOG_TIMEOUT);
  TransitionToState(STATE_FAIL_SAFE);
}

void HandleModeChangeReqMessage(message M008_Mode_Change_Req msg)
{
  write("HPC: Mode change requested: %d -> %d", currentRegenMode, (enum RegenState)msg.Requested_Mode);
  SendModeChangeResponse(msg);
}

void HandleBatteryBasicMessage(message M006_Battery_Basic msg)
{
  batterySOC = msg.Battery_SOC;
  batteryTemp = msg.Battery_Temp;

  if ((batterySOC >= BATTERY_SOC_LIMIT || batteryTemp < BATTERY_TEMP_MIN || batteryTemp > BATTERY_TEMP_MAX))
  {
      if(currentState == STATE_NORMAL) TransitionToState(STATE_BATTERY_PROTECTION);
  }
  else
  {
      if(currentState == STATE_BATTERY_PROTECTION) TransitionToState(STATE_NORMAL);
  }
}

void HandleRegenTorqueFeedbackMessage(message M002_Regen_Torque_Feedback msg)
{
  float actualRegen;
  float torqueDifference;
  message M003_Friction_Brake_Req frictionReq;
    
  actualRegen = (msg.Actual_Regen_Torque * 0.1) - 3200;
  torqueDifference = targetRegenTorque - actualRegen;

  if (torqueDifference > 50.0 && currentState == STATE_NORMAL)
  {
    frictionReq.Required_Friction_Torque = (word)(torqueDifference / 0.1);
    frictionReq.Brake_Request_Type = 0;
    frictionReq.Brake_Force_Distribution = 50;
    frictionReq.Control_Flags = 0x01;
    frictionReq.E2E_Counter = ++watchdogCounter;

    gCrcData[0] = (byte)(frictionReq.Required_Friction_Torque & 0xFF);
    gCrcData[1] = (byte)((frictionReq.Required_Friction_Torque >> 8) & 0xFF);
    gCrcData[2] = frictionReq.Brake_Request_Type;
    gCrcData[3] = frictionReq.Brake_Force_Distribution;
    gCrcData[4] = frictionReq.Control_Flags;
    gCrcData[5] = frictionReq.E2E_Counter;
    
    gCrcRetval = Crc_CalculateCRC16(gCrcData, 6, 0, 6, 0, 1, gCrcValue);
    if (gCrcRetval == 0)
    {
        frictionReq.E2E_CRC16 = (word)gCrcValue;
    }
    else
    {
        write("HPC: CRC Calculation failed for M003_Friction_Brake_Req with error: %d", gCrcRetval);
        frictionReq.E2E_CRC16 = 0x0000;
    }

    output(frictionReq);
    write("HPC: Friction brake compensation requested: %.2f Nm", torqueDifference);
  }
}

void HandleFailSafeStatusMessage(dword faultCode)
{
  if (faultCode == 1)
  {
    write("HPC: CRITICAL FAULT from other ECU DETECTED - Entering FailSafe Mode");
    SetFault(FAULT_CRITICAL_EXTERNAL);
    TransitionToState(STATE_FAIL_SAFE);
  }
}

void HandleVehicleDynamicsMessage(message M005_Vehicle_Dynamics msg)
{
  dword currentTime;
  float deltaTime;
  float deceleration;
  message M013_Brake_Light_Ctrl brakeLight;
  
  currentTime = timeNow();
  
  currentVehicleSpeed = msg.Vehicle_Speed * 0.01;
  currentMotorSpeed = currentVehicleSpeed * 90; // 모터 속도 계산 (예: 100 km/h -> 9000 RPM)
  steeringAngle = (msg.Steering_Angle * 0.1) - 3200;
  apsPosition = msg.APS_Position;
  
  if (gPrevTime_VD > 0)
  {
    deltaTime = (currentTime - gPrevTime_VD) / 1000.0;
    if(deltaTime > 0)
    {
      deceleration = -((currentVehicleSpeed - gPrevVehicleSpeed_VD) / 3.6) / deltaTime;
      if (deceleration > MAX_DECEL_FOR_BRAKE_LIGHT)
      {
        brakeLight.Brake_Light_Command = 1;
        brakeLight.Deceleration_Level = (byte)(deceleration / 0.1);
        output(brakeLight);
        write("HPC: Brake light activated - Deceleration: %.2f m/s^2", deceleration);
      }
    }
  }
  gPrevVehicleSpeed_VD = currentVehicleSpeed;
  gPrevTime_VD = currentTime;
}
