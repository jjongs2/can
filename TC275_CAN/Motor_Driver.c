/**********************************************************************************************************************
 * \file GTM_TOM_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the
 *company in which ordinary course of business you are acting and (ii) Infineon
 *Technologies AG or its licensees. If and as long as no such terms of use are
 *agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software,
 *and to permit third-parties to whom the Software is furnished to do so, all
 *subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer, must
 *be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 *solely in the form of machine-executable object code generated by a source
 *language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR
 *ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Motor_Driver.h"

#include "IfxGtm_Tom_Pwm.h"
#include "IfxPort.h"
#include "IfxScuWdt.h"
#include "Ifx_Types.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global
 * variables--------------------------------------------------*/
/*********************************************************************************************************************/

IfxGtm_Tom_Pwm_Config g_tomConfig_left;  /* Timer configuration structure  */
IfxGtm_Tom_Pwm_Config g_tomConfig_right; /* Timer configuration structure */
IfxGtm_Tom_Pwm_Driver g_tomDriver_left;  /* Timer Driver structure  */
IfxGtm_Tom_Pwm_Driver g_tomDriver_right; /* Timer Driver structure */

/*********************************************************************************************************************/
/*-------------------------------------------------Function
 * Prototype------------------------------------------------*/
/*********************************************************************************************************************/

/* Start Initialize Encoder ISR */
volatile long long left_enc  = 0;
volatile long long right_enc = 0;
//static uint8 prev_mode = -1;
uint32 leftCompare = 0;
void setMotorDuty(uint32 leftDuty, uint32 rightDuty)
{
    // duty: 0~100 → GTM용 compare value로 변환
    leftCompare  = (PWM_PERIOD * leftDuty) / 100;
    uint32 rightCompare = (PWM_PERIOD * rightDuty) / 100;

    g_tomConfig_left.dutyCycle = leftCompare;
    g_tomConfig_right.dutyCycle = rightCompare;

    IfxGtm_Tom_Pwm_init(&g_tomDriver_left, &g_tomConfig_left);
    IfxGtm_Tom_Pwm_init(&g_tomDriver_right, &g_tomConfig_right);
}

IFX_INTERRUPT(EXTI_L_ENC_A, 1, ISR_PRIORITY_L_ENC_A);
void EXTI_L_ENC_A(void)
{
    uint8 sensorA = IfxPort_getPinState(MOTOR_L_ENC_A);
    uint8 sensorB = IfxPort_getPinState(MOTOR_L_ENC_B);

    left_enc += ((sensorA == sensorB) ? -1 : 1);
}

IFX_INTERRUPT(EXTI_L_ENC_B, 1, ISR_PRIORITY_L_ENC_B);
void EXTI_L_ENC_B(void)
{
    uint8 sensorA = IfxPort_getPinState(MOTOR_L_ENC_A);
    uint8 sensorB = IfxPort_getPinState(MOTOR_L_ENC_B);

    left_enc += ((sensorA == sensorB) ? 1 : -1);
}

IFX_INTERRUPT(EXTI_R_ENC_A, 1, ISR_PRIORITY_R_ENC_A);
void EXTI_R_ENC_A(void)
{
    uint8 sensorA = IfxPort_getPinState(MOTOR_R_ENC_A);
    uint8 sensorB = IfxPort_getPinState(MOTOR_R_ENC_B);

    right_enc += ((sensorA == sensorB) ? 1 : -1);
}

IFX_INTERRUPT(EXTI_R_ENC_B, 1, ISR_PRIORITY_R_ENC_B);
void EXTI_R_ENC_B(void)
{
    uint8 sensorA = IfxPort_getPinState(MOTOR_R_ENC_A);
    uint8 sensorB = IfxPort_getPinState(MOTOR_R_ENC_B);

    right_enc += ((sensorA == sensorB) ? -1 : 1);
}
/* End Initialize Encoder ISR */

/* Start Initialize Motor Control */
void initMotorCtl(void)
{
    IfxPort_setPinModeOutput(MOTOR_L_BRAKE,
                             IfxPort_OutputMode_pushPull,
                             IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(MOTOR_R_BRAKE,
                             IfxPort_OutputMode_pushPull,
                             IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(MOTOR_L_DIR,
                             IfxPort_OutputMode_pushPull,
                             IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(MOTOR_R_DIR,
                             IfxPort_OutputMode_pushPull,
                             IfxPort_OutputIdx_general);
}

void initGtmTomPwm(void)
{
    IfxGtm_enable(&MODULE_GTM); /* Enable GTM */

    IfxGtm_Cmu_enableClocks(&MODULE_GTM,
                            IFXGTM_CMU_CLKEN_ALL); /* Enable the FXU clock */

    /* Initialize the configuration structure with default parameters */
    IfxGtm_Tom_Pwm_initConfig(&g_tomConfig_left, &MODULE_GTM);
    IfxGtm_Tom_Pwm_initConfig(&g_tomConfig_right, &MODULE_GTM);

    g_tomConfig_left.tom =
        MOTOR_L_PWM.tom; /* Select the TOM depending on the LED          */
    g_tomConfig_left.tomChannel =
        MOTOR_L_PWM.channel; /* Select the channel depending on the LED      */
    g_tomConfig_left.period = PWM_PERIOD; /* Set the timer period */
    g_tomConfig_left.pin.outputPin =
        &MOTOR_L_PWM; /* Set the LED port pin as output               */
    g_tomConfig_left.synchronousUpdateEnabled =
        TRUE; /* Enable synchronous update                    */

    g_tomConfig_right.tom =
        MOTOR_R_PWM.tom; /* Select the TOM depending on the LED          */
    g_tomConfig_right.tomChannel =
        MOTOR_R_PWM.channel; /* Select the channel depending on the LED      */
    g_tomConfig_right.period = PWM_PERIOD; /* Set the timer period */
    g_tomConfig_right.pin.outputPin =
        &MOTOR_R_PWM; /* Set the LED port pin as output               */
    g_tomConfig_right.synchronousUpdateEnabled =
        TRUE; /* Enable synchronous update                    */

    IfxGtm_Tom_Pwm_init(&g_tomDriver_right,
                        &g_tomConfig_right); /* Initialize the GTM TOM */
    IfxGtm_Tom_Pwm_init(&g_tomDriver_left,
                        &g_tomConfig_left); /* Initialize the GTM TOM         */
    IfxGtm_Tom_Pwm_start(&g_tomDriver_right, TRUE); /* Start the PWM */
    IfxGtm_Tom_Pwm_start(&g_tomDriver_left, TRUE);  /* Start the PWM  */
}

void initERU(void)
{
    // L_A  22
    SCU_EICR1.B.EXIS0 = 0x2;
    SCU_EICR1.B.FEN0  = 1;
    SCU_EICR1.B.REN0  = 1;
    SCU_EICR1.B.EIEN0 = 1;
    SCU_EICR1.B.INP0  = 0x0;

    SCU_IGCR0.B.IGP0 = 0x1;

    SRC_SCU_SCU_ERU0.B.SRPN = ISR_PRIORITY_L_ENC_A;
    SRC_SCU_SCU_ERU0.B.SRE  = 1;
    SRC_SCU_SCU_ERU0.B.TOS  = 0x1;

    // L_B  31
    SCU_EICR1.B.EXIS1 = 0x1;
    SCU_EICR1.B.FEN1  = 1;
    SCU_EICR1.B.REN1  = 1;
    SCU_EICR1.B.EIEN1 = 1;
    SCU_EICR1.B.INP1  = 0x1;

    SCU_IGCR0.B.IGP1 = 0x1;

    SRC_SCU_SCU_ERU1.B.SRPN = ISR_PRIORITY_L_ENC_B;
    SRC_SCU_SCU_ERU1.B.SRE  = 1;
    SRC_SCU_SCU_ERU1.B.TOS  = 0x1;

    // R_A  72
    SCU_EICR3.B.EXIS1 = 0x2;
    SCU_EICR3.B.FEN1  = 1;
    SCU_EICR3.B.REN1  = 1;
    SCU_EICR3.B.EIEN1 = 1;
    SCU_EICR3.B.INP1  = 0x2;

    SCU_IGCR1.B.IGP0 = 0x1;

    SRC_SCU_SCU_ERU2.B.SRPN = ISR_PRIORITY_R_ENC_A;
    SRC_SCU_SCU_ERU2.B.SRE  = 1;
    SRC_SCU_SCU_ERU2.B.TOS  = 0x1;

    // R_B  63
    SCU_EICR3.B.EXIS0 = 0x3;
    SCU_EICR3.B.FEN0  = 1;
    SCU_EICR3.B.REN0  = 1;
    SCU_EICR3.B.EIEN0 = 1;
    SCU_EICR3.B.INP0  = 0x3;

    SCU_IGCR1.B.IGP1 = 0x1;

    SRC_SCU_SCU_ERU3.B.SRPN = ISR_PRIORITY_R_ENC_B;
    SRC_SCU_SCU_ERU3.B.SRE  = 1;
    SRC_SCU_SCU_ERU3.B.TOS  = 0x1;
}

void Enc_Reset(void)
{
    left_enc  = 0;
    right_enc = 0;
}

void initMotor(void)
{
    initMotorCtl();
    initGtmTomPwm();
    initERU();
    Car_Control(HOLD, 0);
    Enc_Reset();
}
/* End Initialize Motor Control */

/* Start Define Car Control Functions */
void setLeftMotorForward(void)
{
    IfxPort_setPinState(MOTOR_L_BRAKE, IfxPort_State_low);
    IfxPort_setPinState(MOTOR_L_DIR, CW);
}

void setLeftMotorBackward(void)
{
    IfxPort_setPinState(MOTOR_L_BRAKE, IfxPort_State_low);
    IfxPort_setPinState(MOTOR_L_DIR, ACW);
}

void setLeftMotorStop(void)
{
    g_tomConfig_left.dutyCycle = 0;
    IfxGtm_Tom_Pwm_init(&g_tomDriver_left, &g_tomConfig_left);
    IfxPort_setPinState(MOTOR_L_BRAKE, IfxPort_State_high);
}

void setRightMotorForward(void)
{
    IfxPort_setPinState(MOTOR_R_BRAKE, IfxPort_State_low);
    IfxPort_setPinState(MOTOR_R_DIR, ACW);
}

void setRightMotorBackward(void)
{
    IfxPort_setPinState(MOTOR_R_BRAKE, IfxPort_State_low);
    IfxPort_setPinState(MOTOR_R_DIR, CW);
}

void setRightMotorStop(void)
{
    g_tomConfig_right.dutyCycle = 0;
    IfxGtm_Tom_Pwm_init(&g_tomDriver_right, &g_tomConfig_right);
    IfxPort_setPinState(MOTOR_R_BRAKE, IfxPort_State_high);
}

/* End Define Car Control Functions */

/*********************************************************************************************************************/
/*--------------------------------------------Function
 * Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

int Get_Encoder_Value(boolean LorR)
{
    return (LorR) ? left_enc : right_enc;
}

/* Start Car Control Function */
void Car_Control(uint8 mode, uint32 value)
{
    static uint8 prev_mode = -1;

    if (mode != prev_mode)
    {
        if (mode != HOLD)
        {
            Enc_Reset();
        }
        prev_mode = mode;
    }

    switch (mode)
    {
    case Forward_straight:
        setLeftMotorForward();
        setRightMotorForward();
        break;
    case Backward_straight:
        setLeftMotorBackward();
        setRightMotorBackward();
        break;
    case Forward_left:
        setLeftMotorForward();
        setRightMotorStop();
        break;
    case Forward_right:
        setLeftMotorStop();
        setRightMotorForward();
        break;
    case Backward_left:
        setLeftMotorBackward();
        setRightMotorStop();
        break;
    case Backward_right:
        setLeftMotorStop();
        setRightMotorBackward();
        break;
    case HOLD:
    default:
        setLeftMotorStop();
        setRightMotorStop();
        break;
    }
}
/* End Car Control Function */
